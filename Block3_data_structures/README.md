# Block 3. Data Structures
## [1067. Disk Tree](https://acm.timus.ru/problem.aspx?space=1&num=1067&locale=en)

#### Explanation (in Russian):
Простая реализация дерева (структура с именем и мапой для хранения детей)ю
Вывод - обход в глубину.


## [1494. Monobilliards](https://acm.timus.ru/problem.aspx?space=1&num=1494&locale=en)

#### Explanation (in Russian):
Воспользуясь стеком, буду класть шары в лунку (стек), как это делал Чичиков - на вершине всегда будет последний забитый шар.
* если данный шар больше top на 1, то все хорошо, ревизор проверил его в предыдущий и в этот раз.
* если данный шар больше top на 2 и больше, то тоже все хорошо, просто ревизор не проверял какое-то время лунку. Тогда дополню лунку шарами от предыдущего проверенного, до текущего (не включительно)
* если данный шар меньше или равен, то проверим, является ли шар тем, который мы ожидаем в стеке, который сохранили в предыдущем пункте, или нет. Если не соответствует: Чичиков - жулик. 

Асимптотика: O(n)

## [1521. War Games 2](https://acm.timus.ru/problem.aspx?space=1&num=1521&locale=en)

#### Explanation (in Russian):


## [1628. White Streaks](https://acm.timus.ru/problem.aspx?space=1&num=1628&locale=en)

#### Explanation (in Russian):
* Сначала добавил точки-границы: сверху, слева, снизу, справа (всего 2(m+n)).
* Отсортировал их по строчкам (т.е. сначала внутри строки, а затем между), нашел сколько горизонтальных полос длиной больше 1
* Аналогично отсортировал их по столбца (т.е. сначала внутри столбца, а затем между), нашел сколько вертикальных полос длиной больше 1
* В предыдущих шагах я еще запоминал, есть ли вертикальные и горизонтальные полосы длиной один. Если полоса является и горизонтально и вертикально длины 1 - то это маленький квадратик, и значит его надо тоже учесть.
* Сложность: O((k+m+n)*log(k+m+n))

## [1650. Billionaires](https://acm.timus.ru/problem.aspx?space=1&num=1650&locale=en)

#### Explanation (in Russian):

Буду хранить несколько сруктур: 
* для человека - его город и деньги
* для городов - сколько в них сейчас денег, и "индекс" - ниже будет понятно зачем оно, при каждом приезде/выезде из города инкрементим его.
Эти две структуры - словари - для быстрого поиска.
* очередь с приоритетом, в которой буду хранить город, и то, сколько в нем сейчас денег (чтобы быстро доставать максимум), но так как есть доступ только к последнему элементу, удалять все записи для города, при изменении его "бюджета" - невыгодно по времени. Поэтому я придумал "индексы". Каждый раз, когда я буду брать с вершины очереди город, я буду смотреть на актуальность индекса, если он не актуальный (значит кто-то съехал из этого города и сейчас его бюджет меньше), то беру следующий по приоритету город. Самое главное аккуратно смотреть, чтобы не дойти до пустого списка и не впасть в Runtime error.

Ну и тогда алгоритм прост, пока мы в одном дне, я перемещаю все куда надо, меняю бюджет городов, а как только происходит смена дня, считаю, есть ли города с приоритетным бюджетом,если да, то пополняю ответ.


